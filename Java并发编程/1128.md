#

## 第一章

## 什么是线程安全性

> 一个类是线程安全的，是指在被多个线程访问时，类可以持续进行正确的行为.

## 线程的生命周期

* NEW
  * 用关键字new创建对象时处于该状态
  
* RUNNABLE
  * 调用了start方法后，此时才真正在JVM中创建了一个线程，当线程具备执行资格，但没有真正执行起来而是在等待CPU的调度时处于该状态

* RUNNING
  * CPU选中了该线程后处于RUNNING状态，同时也处于RUNNABLE

* BLOCKED
  * 调用sheep函数，或发生阻塞等等时进入该状态

* TERMINATED
  * 线程的最终状态，意味着线程结束

## 第二章

### JVM内存结构
  
* 程序计数器
  >存放当前线程接下来要执行的字节码指令，分支，循环等等，线程私有
* Java虚拟机栈
  >JVM运行时创建，在线程中，方法的执行都会创建一个栈帧，用于存放局部变量表，操作栈等等，方法的调用对应着栈帧的压入弹出，线程私有
* 本地方法栈
  >提供调用本地方法的接口(JNI)，也就是c++程序，线程私有
* 堆内存
  >JVM最大的内存区域，所有线程共享，几乎所有的对象都放在这里，是垃圾回收器的重点照顾区域，也被称为GC堆
* 方法区
  >被多个线程共享，主要用于存储已经被虚拟机加载的类信息，常量，静态变量等

### 守护进程

* 自动结束生命周期

## 第三章

### 1.使用TimeUtil代替Thread.sheep

* TimeUtil.HOURS.sheep(3);

### 2.线程yield

* 调用yield方法会使线程从RUNNING切换到RUNNABLE状态，但是yield只是一个提示(hint),CPU调度并不会担保每次都能满足yield的提示，不常用

### 3.线程优先级并不可靠

### 4.线程interrupt

* interrupt方法
  >当线程进入阻塞状态时，调用interrupt则会打断这种阻塞
* isInterrupted方法
  >判断当前线程是否被中断，不会影响标志
* interrupted方法
  >也用于判断当前线程是否中断，但是调用该方法会直接擦除掉线程的interrupt标志

### 5.线程join

* join某个线程A，会使当前线程B进入等待，直到线程A结束生命周期，或者到达给定时间，此时线程B处于BLOCKED状态

### 6.关闭线程

* 正常结束

* 捕获中断信号关闭线程

* 使用volatile开关控制

## 第四章

### 1.synchronized关键字

* 实现一个简单的策略来防止线程干扰和内存一致性错误
  >提供一种锁机制，确保共享变量的互斥访问，防止数据不一致

* synchronized用法
  >可以对代码块或方法进行修饰，不能对class以及变量进行修饰
  * 同步方法
    ```java
    public synchronized void sync(){
        ...
    }
    ```
  * 同步代码块
    ```java
    private final Object MUTEX = new Object();
    public void sync(){
        synchronized (MUTEX){
            ...
        }
    }
    ```

## 第五章

### 1.同步和异步阻塞

  >同步阻塞消息处理：服务器接收客户的请求后开辟线程处理客户请求，经过处理后将结果返回给客户端
  >异步非阻塞消息处理：客户端提交Event后得到一个相应的工单并且返回，Event则会放在Event队列中，服务端有多线程从队列获取任务进行异步处理并保存结果到另一个结果集，客户端凭借工单查询结果

### 2.单线程间的通信

* wait和notify
  * 