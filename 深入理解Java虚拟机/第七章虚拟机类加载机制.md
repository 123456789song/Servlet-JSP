# 第七章 虚拟机类加载机制

## 1. 虚拟机类加载机制

* **1.1 类加载描述**
    > 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验 、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型
    > * 类型的加载 、连接和初始化过程都是在程序运行期间完成，即运行期类加载
* **1.2 类加载的时机**
    > * 加载
    > * 验证 、准备 、解析 ( 统称为**连接** )
    > * 初始化
    > * 使用
    > * 卸载
* **1.3 五种情况必须立即对类进行 " 初始化 "**
    > * 遇到 new 、getstatic 、putstatic 或 invokestatic 这四条字节码指令时
    > * 使用reflect包的方法对类进行反射调用的时候
    > * 初始化一个类时，其父类未初始化，则触发其父类的初始化
    > * 当虚拟机启动时，用户指定的一个要执行的主类 ( 包含main() 方法的类 )
    > * 使用jdk 1.7 的动态语言支持的某些情况

## 2. 类加载的过程

* **2.1 加载**
    > * 通过一个类的**全限定名**来获取定义此类的二进制字节流
    > * 将这个字节流所代表的**静态存储结构**转化为**方法区**的运行时数据结构
    > * 在内存中生成一个代表这个类的 java.lang.Class对象，这个对象作为**方法区这个类的各种数据的访问入口**
    >
    > 加载阶段与连接阶段的部分内容是交叉进行的，当是，这两个阶段的开始时间任然保持固定的先后顺序
* **2.2 验证**
    > 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求
    > * 文件格式验证
    > * 元数据验证
    > * 字节码验证
    > * 符号引用验证
* **2.3 准备**
    > 准备阶段是正式为**类变量分配内存**并**设置变量初始值**的阶段，这些变量所使用的内存都将在**方法区**中进行分配
    > * 仅分配类变量，不包括实例变量
    > * 初始值通常情况下指的是数据类型的零值
* **2.4 解析**
    > 解阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，，解析动作主要针对**类或接口 、字段 、类方法 、接口方法 、方法类型 、方法句柄和调用点限定符**7类符号引用进行
    > * 符号引用 ：以一组符号来描述所引用的目标，与虚拟机实现的内存布局无关，引用目标不一定加载到内存中
    > * 直接引用 ：可以是直接指向目标的指针 、相对偏移量或是一个能间接定位到目标的句柄，与虚拟机实现的内存布局相关，引用目标已经在内存中存在
* **2.5 初始化**
    > 类初始化是类加载过程的最后一步，在准备阶段，变量已经赋值过一次初始值，在初始化阶段则根据程序制定的计划去初始化变量和其他资源

## 3. 类加载器

* **3.1 定义**
    > 类加载阶段中的 " 通过一个类的全限定名来获取描述此类的二进制字节流 " 这个动作放到虚拟机外部实现，实现这个动作的代码模块称为 " 类加载器 "
* **3.2 类和类加载器的关系**
    > 对于任意一个类，都需要由加载它的类加载器和这个类的=本身一同确立其在虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名称空间
    > * 比较两个类是否 " 相等 "，要在这两个类是由同一个类加载器加载的前提下才由意义
* **3.3 双亲委派模型 ( 类加载器的分类 )**
    > * 从虚拟机角度来讲
    >   * 启动类加载器 : 这个类加载器使用C++实现，是虚拟机自身的一部分
    >   * 其他加载器 ：由Java语言实现，独立于虚拟机外部，全部继承自抽象类java.lang.ClassLoader
    > * 从开发人员的角度
    >   * 启动类加载器 : 这个类加载器负责将存放在 <JAVA_HONE>\lib 目录中，或指定参数路径中的，被虚拟机识别的类库加载到虚拟机内存中。无法被程序员直接引用
    >   * 扩展类加载器 ：负责加载 <JAVA_HONE>\lib\ext 目录中的，或者被系统变量指定路径中的所有类库。开发者可以直接使用
    >   * 应用程序类加载器 : 一般称为系统类加载器，负责加载用户类路径上所指定的类库。开发者可以直接使用。一般情况下这个就是**程序中默认的类加载器**
    >   * 自定义类加载器
    > * 3.4 双亲委派模型
    >   * 模型 ：**自定义加载器 -> 应用程序类加载器 -> 扩展类加载器 -> 启动类加载器**
    >   * 如果一个类加载器收到类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此。只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才尝试自己去加载
    
