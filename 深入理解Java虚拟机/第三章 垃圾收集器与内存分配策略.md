# 第三章 垃圾收集器与内存分配策略

## 1. 确定对象的存活状态

* 1.1 引用计数算法
    > 给对象添加一个引用计数器，每当有一个地方引用它时则计数器加一，当引用失效时则计数器家减一。任何时候计数器为零的对象是不可能再被使用的。
    > * 但是，主流的Java虚拟机没有选用引用计数器法来管理内存，最主要的原因是它很难解决对象的相互循环引用的问题
* 1.2 可达性分析算法
    > 通过一系列的称为 " GC Roots " 的对象作为起始点，从这些节点开始向下搜索，所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
    > * GC Roots 的对象包括下面几种
    >   * 虚拟机栈中的引用对象
    >   * 方法区中的类静态属性引用的对象
    >   * 方法区中的常量引用对象
    >   * 本地方法栈中的JNI引用的对象

## 2. 引用的分类

* 2.1 强引用
    > 程序代码中普遍存在的，类似 " Object obj = new Object() " 这类的引用，只要强引用还在，垃圾收集器永远不会回收被引用的对象
* 2.2 软引用
    > 用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收
* 2.3 弱引用
    > 也是用来描述非必须对象的，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。无论内存是否足够都会被回收
* 2.4 虚引用
    > 也称为幽灵引用或幻影引用，一个对象是否有虚引用并不会对其生存时间构成影响。为一个对象设置虚引用的唯一目的就是在这个对象被收集器回收时收到一个系统通知

## 3. 垃圾收集算法

* 3.1 标记-清除算法
    > 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象
    > * 两个缺点
    >   * 标记和清除两个过程的效率不高
    >   * 空间问题，标记清除后会产生大量不连续的内存碎片
* 3.2 复制算法
    > 将可用的内存按容量划分大小相等的两块，每次只使用其中一块。当这一块的内存用完的，就将还存活着的对象复制到另外一块上面，然后再把使用过的内存空间一次清理掉。
    > * 优化方法
    > 不需要按照 1：1 的比例划分内存空间，而是将内存划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor空间。当回收时，将活着的对象复制到另外一块Survivor中，最后清理刚才使用的空间
* 3.3 标记-整理算法
    > 标记的过程同 " 标记-清除 " 算法一样，当后续不是直接对可回收的对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存
* 3.4 分代收集算法
    >当代商业的垃圾收集都采用这种 " 分代收集 " 算法，根据对象存活周期的不同将内存划分为几块。一般把Java堆分为新生代和老年代，根据各个年代的特点采用不同的收集算法

## 4. 垃圾收集器

* 4.1 基于HotSpot虚拟机的收集器
    > * Serial：最基本、古老的、单线程的收集器，曾经是用于新生代收集的唯一选择
    > * ParNew：Serial的多线程版本
    > * Parallel Scavenge: 新生代收集，同时也是并行多线程收集器
    > * Serial Old: 是Serial收集器的老年代版本
    > * Parallel Old: 是Parallel Scavenge收集器的老年代版本
    > * CMS: 是一种以获取最短回收停顿时间为目标的收集器，并发收集低停顿
    > * G1: 特点是并行与并发、分代收集、空间整合、可预测停顿

## 5. 内存分配与回收策略

* 5.1 几条普遍的内存分配原则
    > * 对象优先在新生代Eden分配
    >   * Minor GC 和 Full GC
    >   新生代GC ( Minor GC ) : 指发生在新生代的垃圾收集动作，比较频繁，回收速度快
    >   老年代GC ( Major / Full GC ) : 指发生在老年代，速度比较慢
    > * 大对象直接而进入老年代
    > * 长期存活的的对象将进入老年代
    > * 动态年龄判定  
